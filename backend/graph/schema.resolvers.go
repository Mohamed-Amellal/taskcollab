package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"task-api/db/models"
	"task-api/graph/model"
	"task-api/internal/auth"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	if strings.TrimSpace(input.Email) == "" || strings.TrimSpace(input.Password) == "" || strings.TrimSpace(input.Name) == "" {
		return nil, fmt.Errorf("name, email, and password are required")
	}

	var existing models.User
	if err := r.DB.First(&existing, "email = ?", strings.ToLower(input.Email)).Error; err == nil {
		return nil, fmt.Errorf("email already in use")
	}

	hash, err := auth.HashPassword(input.Password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password")
	}

	user := models.User{
		Name:         input.Name,
		Email:        strings.ToLower(input.Email),
		PasswordHash: hash,
	}
	if err := r.DB.Create(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to create user")
	}

	if r.JWTSecret == "" {
		return nil, fmt.Errorf("jwt secret is not configured")
	}
	jwt, err := auth.GenerateToken(user.ID, r.JWTSecret, 24*time.Hour)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}

	return &model.AuthPayload{
		Token: jwt,
		User:  mapUser(user),
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	var user models.User
	if err := r.DB.First(&user, "email = ?", strings.ToLower(input.Email)).Error; err != nil {
		return nil, fmt.Errorf("invalid email or password")
	}

	if !auth.CheckPassword(user.PasswordHash, input.Password) {
		return nil, fmt.Errorf("invalid email or password")
	}

	if r.JWTSecret == "" {
		return nil, fmt.Errorf("jwt secret is not configured")
	}
	jwt, err := auth.GenerateToken(user.ID, r.JWTSecret, 24*time.Hour)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}

	return &model.AuthPayload{
		Token: jwt,
		User:  mapUser(user),
	}, nil
}

// CreateWorkspace is the resolver for the createWorkspace field.
func (r *mutationResolver) CreateWorkspace(ctx context.Context, input model.CreateWorkspaceInput) (*model.Workspace, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	workspace := models.Workspace{
		Name:    input.Name,
		OwnerID: user.ID,
	}

	if err := r.DB.Create(&workspace).Error; err != nil {
		return nil, fmt.Errorf("failed to create workspace")
	}

	membership := models.Membership{
		UserID:      user.ID,
		WorkspaceID: workspace.ID,
		Role:        string(model.MembershipRoleOwner),
	}
	if err := r.DB.Create(&membership).Error; err != nil {
		return nil, fmt.Errorf("failed to create membership")
	}

	if err := r.DB.Preload("Owner").Preload("Members.User").Preload("Projects").First(&workspace, "id = ?", workspace.ID).Error; err != nil {
		return nil, fmt.Errorf("failed to load workspace")
	}

	return mapWorkspace(workspace), nil
}

// InviteUserToWorkspace is the resolver for the inviteUserToWorkspace field.
func (r *mutationResolver) InviteUserToWorkspace(ctx context.Context, input model.InviteUserInput) (*model.Membership, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	workspaceID, err := uuid.Parse(input.WorkspaceID)
	if err != nil {
		return nil, fmt.Errorf("invalid workspace id")
	}

	role, err := getMembershipRole(user.ID, workspaceID, r.DB)
	if err != nil {
		return nil, err
	}
	if role != model.MembershipRoleOwner && role != model.MembershipRoleAdmin {
		return nil, fmt.Errorf("not authorized")
	}

	var invited models.User
	if err := r.DB.First(&invited, "email = ?", strings.ToLower(input.Email)).Error; err != nil {
		return nil, fmt.Errorf("user not found")
	}

	var existing models.Membership
	if err := r.DB.First(&existing, "user_id = ? AND workspace_id = ?", invited.ID, workspaceID).Error; err == nil {
		return nil, fmt.Errorf("user is already a member")
	}

	membership := models.Membership{
		UserID:      invited.ID,
		WorkspaceID: workspaceID,
		Role:        string(input.Role),
	}
	if err := r.DB.Create(&membership).Error; err != nil {
		return nil, fmt.Errorf("failed to invite user")
	}

	if err := r.DB.Preload("User").Preload("Workspace.Owner").First(&membership, "id = ?", membership.ID).Error; err != nil {
		return nil, fmt.Errorf("failed to load membership")
	}

	return mapMembership(membership), nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.CreateProjectInput) (*model.Project, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	workspaceID, err := uuid.Parse(input.WorkspaceID)
	if err != nil {
		return nil, fmt.Errorf("invalid workspace id")
	}

	role, err := getMembershipRole(user.ID, workspaceID, r.DB)
	if err != nil {
		return nil, err
	}
	if role != model.MembershipRoleOwner && role != model.MembershipRoleAdmin {
		return nil, fmt.Errorf("not authorized")
	}

	project := models.Project{
		Name:        input.Name,
		WorkspaceID: workspaceID,
	}
	if err := r.DB.Create(&project).Error; err != nil {
		return nil, fmt.Errorf("failed to create project")
	}

	if err := r.DB.Preload("Workspace.Owner").First(&project, "id = ?", project.ID).Error; err != nil {
		return nil, fmt.Errorf("failed to load project")
	}

	return mapProject(project), nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input model.CreateTaskInput) (*model.Task, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	projectID, err := uuid.Parse(input.ProjectID)
	if err != nil {
		return nil, fmt.Errorf("invalid project id")
	}

	var project models.Project
	if err := r.DB.First(&project, "id = ?", projectID).Error; err != nil {
		return nil, fmt.Errorf("project not found")
	}

	if _, err := getMembershipRole(user.ID, project.WorkspaceID, r.DB); err != nil {
		return nil, err
	}

	var assignedTo *uuid.UUID
	if input.AssignedTo != nil {
		assignedID, err := uuid.Parse(*input.AssignedTo)
		if err != nil {
			return nil, fmt.Errorf("invalid assigned user id")
		}
		assignedTo = &assignedID
	}

	task := models.Task{
		Title:       input.Title,
		Description: valueOrEmpty(input.Description),
		Status:      string(model.TaskStatusTodo),
		Priority:    string(input.Priority),
		ProjectID:   project.ID,
		AssignedTo:  assignedTo,
	}
	if err := r.DB.Create(&task).Error; err != nil {
		return nil, fmt.Errorf("failed to create task")
	}

	if err := r.DB.Preload("Assignee").Preload("Project.Workspace.Owner").First(&task, "id = ?", task.ID).Error; err != nil {
		return nil, fmt.Errorf("failed to load task")
	}

	return mapTask(task), nil
}

// UpdateTaskStatus is the resolver for the updateTaskStatus field.
func (r *mutationResolver) UpdateTaskStatus(ctx context.Context, input model.UpdateTaskStatusInput) (*model.Task, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	taskID, err := uuid.Parse(input.TaskID)
	if err != nil {
		return nil, fmt.Errorf("invalid task id")
	}

	var task models.Task
	if err := r.DB.Preload("Project").Preload("Assignee").First(&task, "id = ?", taskID).Error; err != nil {
		return nil, fmt.Errorf("task not found")
	}

	role, err := getMembershipRole(user.ID, task.Project.WorkspaceID, r.DB)
	if err != nil {
		return nil, err
	}
	if task.AssignedTo == nil || *task.AssignedTo != user.ID {
		if role != model.MembershipRoleAdmin && role != model.MembershipRoleOwner {
			return nil, fmt.Errorf("not authorized")
		}
	}

	task.Status = string(input.Status)
	if err := r.DB.Save(&task).Error; err != nil {
		return nil, fmt.Errorf("failed to update task")
	}

	if err := r.DB.Preload("Assignee").Preload("Project.Workspace.Owner").First(&task, "id = ?", task.ID).Error; err != nil {
		return nil, fmt.Errorf("failed to load task")
	}
	return mapTask(task), nil
}

// AssignTask is the resolver for the assignTask field.
func (r *mutationResolver) AssignTask(ctx context.Context, input model.AssignTaskInput) (*model.Task, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	taskID, err := uuid.Parse(input.TaskID)
	if err != nil {
		return nil, fmt.Errorf("invalid task id")
	}

	assigneeID, err := uuid.Parse(input.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user id")
	}

	var task models.Task
	if err := r.DB.Preload("Project").Preload("Assignee").First(&task, "id = ?", taskID).Error; err != nil {
		return nil, fmt.Errorf("task not found")
	}

	role, err := getMembershipRole(user.ID, task.Project.WorkspaceID, r.DB)
	if err != nil {
		return nil, err
	}
	if role != model.MembershipRoleAdmin && role != model.MembershipRoleOwner {
		return nil, fmt.Errorf("not authorized")
	}

	if _, err := getMembershipRole(assigneeID, task.Project.WorkspaceID, r.DB); err != nil {
		return nil, fmt.Errorf("assignee must be a workspace member")
	}

	task.AssignedTo = &assigneeID
	if err := r.DB.Save(&task).Error; err != nil {
		return nil, fmt.Errorf("failed to assign task")
	}

	if err := r.DB.Preload("Assignee").Preload("Project.Workspace.Owner").First(&task, "id = ?", task.ID).Error; err != nil {
		return nil, fmt.Errorf("failed to load task")
	}

	return mapTask(task), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}
	return mapUser(*user), nil
}

// Workspaces is the resolver for the workspaces field.
func (r *queryResolver) Workspaces(ctx context.Context) ([]*model.Workspace, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	var memberships []models.Membership
	if err := r.DB.Preload("Workspace.Owner").Preload("Workspace.Members.User").Preload("Workspace.Projects").Where("user_id = ?", user.ID).Find(&memberships).Error; err != nil {
		return nil, fmt.Errorf("failed to load workspaces")
	}

	workspaces := make([]*model.Workspace, 0, len(memberships))
	for _, membership := range memberships {
		workspaces = append(workspaces, mapWorkspace(membership.Workspace))
	}

	return workspaces, nil
}

// Workspace is the resolver for the workspace field.
func (r *queryResolver) Workspace(ctx context.Context, id string) (*model.Workspace, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	workspaceID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid workspace id")
	}

	if _, err := getMembershipRole(user.ID, workspaceID, r.DB); err != nil {
		return nil, err
	}

	var workspace models.Workspace
	if err := r.DB.Preload("Owner").Preload("Members.User").Preload("Projects").First(&workspace, "id = ?", workspaceID).Error; err != nil {
		return nil, fmt.Errorf("workspace not found")
	}

	return mapWorkspace(workspace), nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, workspaceID string) ([]*model.Project, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	id, err := uuid.Parse(workspaceID)
	if err != nil {
		return nil, fmt.Errorf("invalid workspace id")
	}

	if _, err := getMembershipRole(user.ID, id, r.DB); err != nil {
		return nil, err
	}

	var projects []models.Project
	if err := r.DB.Preload("Workspace.Owner").Where("workspace_id = ?", id).Find(&projects).Error; err != nil {
		return nil, fmt.Errorf("failed to load projects")
	}

	result := make([]*model.Project, 0, len(projects))
	for _, project := range projects {
		result = append(result, mapProject(project))
	}

	return result, nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context, projectID string) ([]*model.Task, error) {
	user, err := requireUser(ctx)
	if err != nil {
		return nil, err
	}

	id, err := uuid.Parse(projectID)
	if err != nil {
		return nil, fmt.Errorf("invalid project id")
	}

	var project models.Project
	if err := r.DB.First(&project, "id = ?", id).Error; err != nil {
		return nil, fmt.Errorf("project not found")
	}

	if _, err := getMembershipRole(user.ID, project.WorkspaceID, r.DB); err != nil {
		return nil, err
	}

	var tasks []models.Task
	if err := r.DB.Preload("Assignee").Preload("Project.Workspace.Owner").Where("project_id = ?", id).Find(&tasks).Error; err != nil {
		return nil, fmt.Errorf("failed to load tasks")
	}

	result := make([]*model.Task, 0, len(tasks))
	for _, task := range tasks {
		result = append(result, mapTask(task))
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func requireUser(ctx context.Context) (*models.User, error) {
	user, ok := auth.UserFromContext(ctx)
	if !ok || user == nil {
		return nil, fmt.Errorf("authentication required")
	}
	return user, nil
}

func getMembershipRole(userID uuid.UUID, workspaceID uuid.UUID, db *gorm.DB) (model.MembershipRole, error) {
	var membership models.Membership
	if err := db.First(&membership, "user_id = ? AND workspace_id = ?", userID, workspaceID).Error; err != nil {
		return "", fmt.Errorf("not a workspace member")
	}
	role := model.MembershipRole(membership.Role)
	if !role.IsValid() {
		return "", errors.New("invalid membership role")
	}
	return role, nil
}

func mapUser(user models.User) *model.User {
	return &model.User{
		ID:        user.ID.String(),
		Name:      user.Name,
		Email:     user.Email,
		CreatedAt: user.CreatedAt,
	}
}

func mapMembership(membership models.Membership) *model.Membership {
	return &model.Membership{
		ID:        membership.ID.String(),
		User:      mapUser(membership.User),
		Workspace: mapWorkspaceShallow(membership.Workspace),
		Role:      model.MembershipRole(membership.Role),
	}
}

func mapProject(project models.Project) *model.Project {
	return &model.Project{
		ID:        project.ID.String(),
		Name:      project.Name,
		Workspace: mapWorkspaceShallow(project.Workspace),
		CreatedAt: project.CreatedAt,
	}
}

func mapTask(task models.Task) *model.Task {
	var description *string
	if task.Description != "" {
		desc := task.Description
		description = &desc
	}
	return &model.Task{
		ID:          task.ID.String(),
		Title:       task.Title,
		Description: description,
		Status:      model.TaskStatus(task.Status),
		Priority:    model.TaskPriority(task.Priority),
		Project:     mapProject(task.Project),
		AssignedTo:  mapUserPtr(task.Assignee),
		CreatedAt:   task.CreatedAt,
		UpdatedAt:   task.UpdatedAt,
	}
}

func mapWorkspace(workspace models.Workspace) *model.Workspace {
	return &model.Workspace{
		ID:        workspace.ID.String(),
		Name:      workspace.Name,
		Owner:     mapUser(workspace.Owner),
		Members:   mapMemberships(workspace.Members),
		Projects:  mapProjects(workspace.Projects),
		CreatedAt: workspace.CreatedAt,
	}
}

func mapWorkspaceShallow(workspace models.Workspace) *model.Workspace {
	return &model.Workspace{
		ID:        workspace.ID.String(),
		Name:      workspace.Name,
		Owner:     mapUser(workspace.Owner),
		Members:   []*model.Membership{},
		Projects:  []*model.Project{},
		CreatedAt: workspace.CreatedAt,
	}
}

func mapUserPtr(user *models.User) *model.User {
	if user == nil {
		return nil
	}
	return mapUser(*user)
}

func mapMemberships(members []models.Membership) []*model.Membership {
	result := make([]*model.Membership, 0, len(members))
	for _, member := range members {
		result = append(result, mapMembership(member))
	}
	return result
}

func mapProjects(projects []models.Project) []*model.Project {
	result := make([]*model.Project, 0, len(projects))
	for _, project := range projects {
		result = append(result, mapProject(project))
	}
	return result
}

func valueOrEmpty(input *string) string {
	if input == nil {
		return ""
	}
	return *input
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
}
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}
*/
